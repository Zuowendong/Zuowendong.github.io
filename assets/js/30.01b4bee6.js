(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{466:function(a,t,s){"use strict";s.r(t);var n=s(48),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("前端开发一般都是基于浏览器环境或者 node 环境，如果反过来，我们是浏览器或 node 的开发者，在我们接收到一段 JavaScript 代码该怎么处理，如何使用 JavaScript 引擎呢？")]),a._v(" "),s("p",[a._v("当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。")]),a._v(" "),s("p",[a._v("然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。")]),a._v(" "),s("p",[a._v("所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。")]),a._v(" "),s("p",[a._v("在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。")]),a._v(" "),s("p",[a._v("但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。")]),a._v(" "),s("p",[a._v("由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语。")]),a._v(" "),s("p",[a._v("我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。")]),a._v(" "),s("h2",{attrs:{id:"宏观和微观任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏观和微观任务"}},[a._v("#")]),a._v(" 宏观和微观任务")]),a._v(" "),s("p",[a._v("JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为"),s("font",{attrs:{color:"#E8684A"}},[a._v("事件循环")]),a._v("。")],1),a._v(" "),s("p",[a._v("在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：")]),a._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("TRUE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    r "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("我们可以看到，整个循环做的事情基本上就是反复“等待 - 执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑......")]),a._v(" "),s("p",[a._v("这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。")]),a._v(" "),s("p",[a._v("在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：")]),a._v(" "),s("img",{attrs:{src:a.$withBase("/pages/宏观和微观任务-1.jpg")}}),a._v(" "),s("p",[a._v("有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了。")]),a._v(" "),s("p",[a._v("例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。")])])}),[],!1,null,null,null);t.default=r.exports}}]);
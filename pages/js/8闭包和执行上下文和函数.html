<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>闭包和执行上下文 | wendZzoo</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="耶斯莫拉">
    
    <link rel="preload" href="/assets/css/0.styles.f30de916.css" as="style"><link rel="preload" href="/assets/js/app.0764bc43.js" as="script"><link rel="preload" href="/assets/js/7.df5249e8.js" as="script"><link rel="preload" href="/assets/js/32.3a3cc3f0.js" as="script"><link rel="prefetch" href="/assets/js/1.f5ace8fd.js"><link rel="prefetch" href="/assets/js/10.f5c4c46e.js"><link rel="prefetch" href="/assets/js/11.7e3d14ae.js"><link rel="prefetch" href="/assets/js/12.a6a54196.js"><link rel="prefetch" href="/assets/js/13.e3898570.js"><link rel="prefetch" href="/assets/js/14.b3e69fbc.js"><link rel="prefetch" href="/assets/js/15.dae0c0bf.js"><link rel="prefetch" href="/assets/js/16.542d9324.js"><link rel="prefetch" href="/assets/js/17.e12f1d49.js"><link rel="prefetch" href="/assets/js/18.1d2e2236.js"><link rel="prefetch" href="/assets/js/19.f7c4ad39.js"><link rel="prefetch" href="/assets/js/2.2767aac7.js"><link rel="prefetch" href="/assets/js/20.60b9d0dc.js"><link rel="prefetch" href="/assets/js/21.f93eaacc.js"><link rel="prefetch" href="/assets/js/22.803aa9bd.js"><link rel="prefetch" href="/assets/js/23.9935b94f.js"><link rel="prefetch" href="/assets/js/24.159312e1.js"><link rel="prefetch" href="/assets/js/25.4a82fb8f.js"><link rel="prefetch" href="/assets/js/26.88216395.js"><link rel="prefetch" href="/assets/js/27.4ce830f5.js"><link rel="prefetch" href="/assets/js/28.efe8daa0.js"><link rel="prefetch" href="/assets/js/29.59b97d3d.js"><link rel="prefetch" href="/assets/js/3.a18bd02b.js"><link rel="prefetch" href="/assets/js/30.01b4bee6.js"><link rel="prefetch" href="/assets/js/31.56826f9e.js"><link rel="prefetch" href="/assets/js/33.12cd56b0.js"><link rel="prefetch" href="/assets/js/34.1909513a.js"><link rel="prefetch" href="/assets/js/35.943ed2a0.js"><link rel="prefetch" href="/assets/js/36.0043e3d4.js"><link rel="prefetch" href="/assets/js/4.42f5992f.js"><link rel="prefetch" href="/assets/js/5.1e843b35.js"><link rel="prefetch" href="/assets/js/8.f72137d6.js"><link rel="prefetch" href="/assets/js/9.3c1d537e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f30de916.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">wendZzoo</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><span class="title">更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="更多" class="mobile-dropdown-title"><span class="title">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/guide/introduce.html" class="nav-link">
  个人
</a></li><li class="dropdown-item"><!----> <a href="/pages/guide/about.html" class="nav-link">
  关于
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><span class="title">更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="更多" class="mobile-dropdown-title"><span class="title">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/guide/introduce.html" class="nav-link">
  个人
</a></li><li class="dropdown-item"><!----> <a href="/pages/guide/about.html" class="nav-link">
  关于
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>闭包和执行上下文</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#执行上下文-执行的基础设施" class="sidebar-link">执行上下文：执行的基础设施</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#var-声明与赋值" class="sidebar-link">var 声明与赋值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#let" class="sidebar-link">let</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#普通函数" class="sidebar-link">普通函数</a></li><li class="sidebar-sub-header"><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#方法" class="sidebar-link">方法</a></li><li class="sidebar-sub-header"><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#生成器函数" class="sidebar-link">生成器函数</a></li><li class="sidebar-sub-header"><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#异步函数" class="sidebar-link">异步函数</a></li></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#this-关键字的行为" class="sidebar-link">this 关键字的行为</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#this-关键字的机制" class="sidebar-link">this 关键字的机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#操作-this-的内置函数" class="sidebar-link">操作 this 的内置函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/js/8%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0.html#new-和-this" class="sidebar-link">new 和 this</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>网上一搜前端面试题，很常见的可能就有：</p> <ul><li>闭包；</li> <li>作用域链；</li> <li>执行上下文；</li> <li>this 值。</li></ul> <p>实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。</p> <img src="/pages/闭包和执行上下文-1.png"> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>闭包翻译自英文单词 closure。</p> <p>在计算机领域，它有三个完全不相同的意义：</p> <ul><li>编译原理中，它是处理语法产生式的一个步骤；</li> <li>计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；</li> <li>而在编程语言领域，它表示一种函数。</li></ul> <p>在上世纪 60 年代，主流的函数式编程语言中有闭包定义，简单理解就是，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。</p> <p>这个古老的闭包定义中，闭包有两个部分：</p> <ul><li>环境部分
<ul><li>环境</li> <li>标识符列表</li></ul></li> <li>表达式部分</li></ul> <p>在如今的 JavaScript 标准中，其实并没有 closure 这个术语，但由古推今，不难在 JavaScript 中找到对应的闭包组成部分:</p> <ul><li>环境部分
<ul><li>环境：函数的词法环境（执行上下文的一部分）</li> <li>标识符列表：函数中用到的未声明的变量</li></ul></li> <li>表达式部分：函数体</li></ul> <p>至此可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。</p> <p>闭包最大的特点就是跨作用域访问变量，一个函数中有另外一个函数，内部函数调用外部函数内的变量，那么，就形成了一个闭包。</p> <p>记住借助闭包的特性，可以保存私有属性:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 私有属性，在demo函数外部不能访问</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token comment">// 函数表达式，实现计算逻辑</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获得操作对象</span>
obj<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用计算表达式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="执行上下文-执行的基础设施"><a href="#执行上下文-执行的基础设施" class="header-anchor">#</a> 执行上下文：执行的基础设施</h2> <p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。</p> <p>如下的这段 JavaScript 代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>要想正确执行它，我们需要知道以下信息：</p> <ol><li>var 把 b 声明到哪里；</li> <li>b 表示哪个变量；</li> <li>b 的原型是哪个对象；</li> <li>let 把 c 声明到哪里；</li> <li>this 指向哪个对象。</li></ol> <p>这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。</p> <p>先通过 var 声明与赋值，let 来分析上下文提供的信息，分析执行上下文中提供的信息。</p> <h2 id="var-声明与赋值"><a href="#var-声明与赋值" class="header-anchor">#</a> var 声明与赋值</h2> <p>来分析一段代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用于函数执行的作用域。也就是说，var 会穿透 for 、if 等语句。</p> <p>在只有 var，没有 let 的旧时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。</p> <p>由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a<span class="token punctuation">;</span>
    <span class="token comment">//code</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a<span class="token punctuation">;</span>
    <span class="token comment">//code</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。</p> <p>推荐写法：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a<span class="token punctuation">;</span>
    <span class="token comment">//code</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="let"><a href="#let" class="header-anchor">#</a> let</h2> <p>let 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。</p> <p>为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。</p> <p>以下语句会产生 let 使用的作用域：</p> <ul><li>for；</li> <li>if；</li> <li>switch；</li> <li>try/catch/finally。</li></ul> <p>任何语句的执行都会依赖特定的上下文。</p> <p>所以，一旦上下文被切换，整个语句的效果可能都会发生改变。</p> <p>那么，切换上下文的时机就显得非常重要了。在 JavaScript，切换上下文最主要的场景就是函数调用。</p> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <h3 id="普通函数"><a href="#普通函数" class="header-anchor">#</a> 普通函数</h3> <p>用 function 关键字定义的函数</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>用 =&gt; 运算符定义的函数</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <p>在 class 中定义的函数</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="生成器函数"><a href="#生成器函数" class="header-anchor">#</a> 生成器函数</h3> <p>用 function * 定义的函数</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="类"><a href="#类" class="header-anchor">#</a> 类</h3> <p>用 class 定义的类，实际上也是函数</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="异步函数"><a href="#异步函数" class="header-anchor">#</a> 异步函数</h3> <p>普通函数、箭头函数和生成器函数加上 async 关键字</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> foo<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于 this 关键字。</p> <h2 id="this-关键字的行为"><a href="#this-关键字的行为" class="header-anchor">#</a> this 关键字的行为</h2> <p>this 是 JavaScript 中的一个关键字，它的使用方法类似于一个变量。</p> <p>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同，如下一个例子：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    showThis<span class="token operator">:</span> showThis<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// global</span>
o<span class="token punctuation">.</span><span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中，我们定义了函数 showThis，我们把它赋值给一个对象 o 的属性，然后尝试分别使用两个引用来调用同一个函数，结果得到了不同的 this 值。</p> <p>普通函数的 this 值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 Reference 类型。</p> <p>Reference 类型由两部分组成：一个对象和一个属性值。不难理解 o.showThis 产生的 Reference 类型，即由对象 o 和属性“showThis”构成。</p> <p>当做一些算术运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。</p> <p>在这个例子中，Reference 类型中的对象被当作 this 值，传入了执行函数时的上下文当中。</p> <p>至此对于 this 的解释已经非常清晰了：调用函数时使用的引用，决定了函数执行时刻的 this 值。实际上从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。</p> <p>这个设计来自 JavaScript 早年，通过这样的方式，巧妙地模仿了 Java 的语法，但是仍然保持了纯粹的“无类”运行时设施。</p> <p>如果，把这个例子稍作修改，换成箭头函数，结果就不一样了：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">showThis</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    showThis<span class="token operator">:</span> showThis<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// global</span>
o<span class="token punctuation">.</span><span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// global</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们看到，改为箭头函数后，不论用什么引用来调用它，都不影响它的 this 值。</p> <p>箭头函数实际上是 lambda 表达式, 它的返回值是一个函数, 它不是一个语句, 所以它产生的函数实际上是计算出来的而不是声明出来的。</p> <p>当然,我们在声明函数的时候也是有计算过程的, 不过如果我们使用 function 来声明闭包, 那么它的 this 其实是由 this 的绑定规则所决定的 但是如果我们使用 lambda 表达式来计算一个函数, 那么它的 this 就取决于 lambda 表达式被计算时的运行环境。</p> <p>接下来我们看看“方法”，它的行为又不一样了：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> showThis <span class="token operator">=</span> o<span class="token punctuation">.</span>showThis<span class="token punctuation">;</span>

<span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
o<span class="token punctuation">.</span><span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这里我们创建了一个类 C，并且实例化出对象 o，再把 o 的方法赋值给了变量 showThis。</p> <p>这时候，我们使用 showThis 这个引用去调用方法时，得到了 undefined。</p> <p>所以，在方法中，我们看到 this 的行为也不太一样，它得到了 undefined 的结果。</p> <p>按照我们上面的方法，不难验证出：生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。</p> <h2 id="this-关键字的机制"><a href="#this-关键字的机制" class="header-anchor">#</a> this 关键字的机制</h2> <p>这里探究一下 JavaScript 内部实现 this 这些行为的机制。</p> <p>函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。</p> <p>在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。</p> <p>当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。</p> <p>这个动作就是切换上下文了，我们假设有这样的代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在别处定义了foo：</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这里的 foo 能够访问 b（定义时词法环境），却不能访问 a（执行时的词法环境），这就是执行上下文的切换机制了。</p> <p>JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：</p> <img src="/pages/闭包和执行上下文-2.png"> <p>当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。</p> <p>而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。</p> <p>[[thisMode]] 私有属性有三个取值。</p> <ul><li>lexical：表示从上下文中找 this，这对应了箭头函数。</li> <li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li> <li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li></ul> <p>非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。</p> <p>函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。</p> <p>代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。</p> <p>这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层 this，例如：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
o<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

o<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o, o, o</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。这里调用三个函数，获得的 this 值是一致的，都是对象 o。</p> <h2 id="操作-this-的内置函数"><a href="#操作-this-的内置函数" class="header-anchor">#</a> 操作 this 的内置函数</h2> <p>Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值，示例如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里 call 和 apply 作用是一样的，只是传参方式有区别。</p> <ul><li>call 参数是对象+字符串，foo.call({}, 1, 2, 3)</li> <li>apply 参数是对象+数组，foo.apply({}, [1, 2, 3]);</li></ul> <p>此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>有趣的是，call、bind 和 apply 用于不接受 this 的函数类型如箭头、class 都不会报错。这时候，它们无法实现改变 this 的能力，但是可以实现传参。</p> <h2 id="new-和-this"><a href="#new-和-this" class="header-anchor">#</a> new 和 this</h2> <p>new 的执行过程:</p> <ul><li>以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；</li> <li>将 this 和调用参数传给构造器，执行；</li> <li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li></ul> <p>显然，通过 new 调用函数，跟直接调用的 this 取值有明显区别:</p> <img src="/pages/闭包和执行上下文-3.png"></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0764bc43.js" defer></script><script src="/assets/js/7.df5249e8.js" defer></script><script src="/assets/js/32.3a3cc3f0.js" defer></script>
  </body>
</html>
